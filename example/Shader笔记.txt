手动minmap
_MinMapPower("MinMap",Range(0.1,1))= 1
float _MinMapPower;
fixed4 col = tex2D(_MainTex, uv,ddx(uv)*_MinMapPower,ddy(uv)*_MinMapPower);


//公告板
float3 forwardCamVec = -normalize(UNITY_MATRIX_V._m20_m21_m22);
float3 rightCamVec = normalize(cross(upCamVec, forwardCamVec));
forwardCamVec = normalize(cross(rightCamVec, upCamVec));
float3x3 rotationCamMatrix = float3x3(rightCamVec, upCamVec,  forwardCamVec);
v.normal = normalize(mul(v.normal, rotationCamMatrix));
v.vertex.xyz = mul(v.vertex.xyz, rotationCamMatrix);

//fast acos
double acos(x) {
   return (-0.69813170079773212*x*x - 0.87266462599716477)* x + 1.5707963267948966;
}

 
Pro
//
elementObject.hideFlags = HideFlags.DontSaveInBuild | HideFlags.DontSaveInEditor | HideFlags.HideInHierarchy | HideFlags.NotEditable;

float4 frag(VertexOutput i, float facing : VFACE) : COLOR {


dynamicbone 
https://chowdera.com/2022/02/202202020915213339.html

//debug symbols
#pragma enable_d3d11_debug_symbols



OpenGL 投影矩阵
Z轴投影后的范围也有所不同，DX为[0, 1]，而OpenGL为[-1, 1]

float d = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture,i.uv_depth);
4      // 根据深度和当前uv坐标反推当前NDC坐标(注意这个坐标已经经过了齐次除法了)
5        float4 NDCPos = float4(i.uv.x*2-1, i.uv.y*2-1, d*2-1,1);
6       // 根据NDC坐标及View-Projection的逆矩阵，将NDC坐标变换到世界坐标下
7       float4 worldPos = mul(_CurrentViewProjectionInverseMatrix,NDCPos);
8    
9       worldPos /= worldPos.w;
